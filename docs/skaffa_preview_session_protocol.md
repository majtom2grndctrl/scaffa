# Skaffa Preview Session Protocol (v0)

> **Status:** Draft / v0 shape  
> **Audience:** Skaffa core contributors, adapter authors, and extension authors  
> **Goal:** Precisely define preview session types, lifecycle, and the selection/override flows across main/renderer/preload/extension host/runtime adapter.

## Agent TL;DR

- Load when: touching **preview session lifecycle**, **selection routing**, or **override routing** across processes.
- Primary artifacts: `PreviewSessionTarget`, `PreviewSessionId`, session lifecycle events, and “which process owns what”.
- Don’t load when: you only need override data shape (`docs/skaffa_override_model.md`) or adapter internals (`docs/skaffa_runtime_adapter_contract.md`).
- Also load: `docs/skaffa_ipc_boundaries_and_sequences.md` for concrete sequence diagrams.

Related:
- [Architecture Plan](./index.md)
- [Skaffa Runtime Adapter Contract](./skaffa_runtime_adapter_contract.md)
- [Skaffa Override Model + Persistence](./skaffa_override_model.md)
- [IPC Boundaries + Key Sequence Diagrams](./skaffa_ipc_boundaries_and_sequences.md)
- [Skaffa MCP Server Contract](./skaffa_mcp_server_contract.md)
- [Skaffa Harness Model](./skaffa_harness_model.md)

---

## 1. Definition

A **Preview Session** is a managed runtime that renders:

- the full app (`app` session)
- a harnessed component instance (`component` session)
- (future) a variant/snapshot context (`variant` session)

Sessions exist so Skaffa can:
- run multiple previews concurrently
- isolate state per preview
- route selection and overrides to the correct runtime

In v0, preview targets are treated as external runtimes (typically a framework dev server). Skaffa can either:
- **attach** to an already-running runtime (`{ type: "app", url }`), or
- **manage** a runtime via a launcher module (`{ type: "app", launcherId }`, recommended for the Harness Model on Vite).

Note: When Skaffa needs to guarantee harness/instrumentation behavior (virtual harness entry + registry-driven transforms), it MUST use managed mode so the runtime is started with Skaffa’s injected tooling.

### 1.1 Editor View (v0) and Preview Mode (Deferred)

In v0, Skaffa focuses on **Editor View**:

- **Editor View**: embedded in the center Workbench workspace. It is an editor canvas:
  - clicks are **consumed for selection** (click-to-select by default)
  - app interaction does not fire in the editor session

**Preview Mode** (a distinct mode/session policy with interact-by-default) is deferred until after v0 “save to disk” workflows are established. In Preview Mode, inspection is modifier-gated (e.g. <kbd>Alt/Option</kbd>+Click).

---

## 2. Session Types (Canonical)

```ts
export type PreviewSessionType = "app" | "component" | "variant"; // "variant" is future

export type PreviewSessionId = string; // generated by Skaffa host

export type PreviewSessionTarget =
  | {
      type: "app";
      /**
       * Attached mode: Skaffa attaches to an already-running dev server.
       * Exactly one of `url` or `launcherId` MUST be provided.
       */
      url?: string;
      /**
       * Managed mode (via a launcher module): Skaffa starts/manages the dev server.
       * Exactly one of `url` or `launcherId` MUST be provided.
       */
      launcherId?: string;
      launcherOptions?: Record<string, unknown>;
    }
  | { type: "component"; componentTypeId: string; harnessUrl?: string }
  | { type: "variant"; variantId: string }; // future
```

Notes:
- For `app` sessions, either `url` (attached) or `launcherId` (managed) MUST be provided (but not both).
- When present, `url` MUST be a full URL including protocol (e.g. `http://localhost:5173`).
- `component` sessions assume an adapter-provided harness that can render an isolated instance.
- `variant` sessions are reserved to preserve Iteration Deck compatibility (see `docs/skaffa_iteration_deck_integration.md`).

Examples:

```ts
// ✅ Correct
{ type: "app", url: "http://localhost:5173" }

// ✅ Correct (managed via launcher)
{ type: "app", launcherId: "my-launcher-id", launcherOptions: {} }

// ❌ Wrong (missing protocol)
{ type: "app", url: "localhost:5173" }
```

---

## 3. Lifecycle and Ownership

### 3.1 Who Owns Sessions

- **Main process owns session lifetimes** and the underlying preview `WebContents` (**BrowserView in v0**).
- **Renderer requests** session start/stop via preload APIs.
- **Extension host may request** sessions through the extension API (future), but never directly controls `WebContents`.

#### 3.1.1 Embedding Primitive (v0): `BrowserView`

v0 embeds the Editor View runtime using an Electron `BrowserView` owned by main.

Layout policy:
- The renderer owns Workbench layout and computes the desired preview viewport rectangle.
- Renderer sends the viewport bounds to main via a preload API.
- Main applies the bounds to the `BrowserView` (and can clamp/sanitize as needed).

Rationale: `BrowserView` keeps the renderer sandboxed (no `webviewTag`) while allowing Skaffa to manage the preview `WebContents` as a host-owned capability.

### 3.2 Session State Machine (v0)

```ts
export type PreviewSessionState =
  | "creating"
  | "loading"
  | "ready"
  | "reloading"
  | "stopped"
  | "disposed"
  | "error";
```

Required lifecycle events:
- `session.created`
- `session.ready` (runtime adapter handshake completed)
- `session.stopped` / `session.disposed`
- `session.error`

### 3.3 Multiple Sessions vs “Active” Editor View (v0)

v0 allows multiple preview sessions to exist concurrently (they appear in the Preview Sessions list), but the Workbench has a single Editor View surface.

Policy (v0):
- The Editor View shows the first `app` session that reaches `ready` state.
- If multiple sessions are running, future versions may allow choosing the active session explicitly (tabs/switcher).

---

## 4. Handshake: Host ↔ Runtime Adapter

After the preview runtime loads, the **runtime adapter** must emit `runtime.ready` (see `docs/skaffa_runtime_adapter_contract.md`).

On `runtime.ready`, the host MUST:
- bind the runtime adapter to the session id
- send `host.init` with the session id + current override state for that session target

This guarantees:
- selection events can be attributed to a session
- overrides are re-applied after reload/navigation

---

## 5. Selection Flow (Pick-to-Select)

### 5.0 Interaction Model (v0): Editor View Click-to-Select

In v0, the embedded runtime is an editor canvas:

- Any click selects the nearest resolvable instance.
- Clicks MUST NOT trigger app interaction (no navigation, no button handlers) in the editor session.
- <kbd>Esc</kbd> clears selection when something is selected.

Recommended affordances:
- Persistent selection highlight for the selected instance.
- Optional hover highlight for candidates under the cursor.

#### 5.0.3 Input Policy Details (v0)

Suppressed by default:
- Pointer interaction is consumed for selection (click-to-select).
- App interaction should not occur (no click handlers, no navigation).

Intercepted by Skaffa (runtime adapter):
- Click is consumed for selection (prevent default + stop propagation).
- Hover highlighting is optional (no need to prevent default).
- <kbd>Esc</kbd> clears selection only when something is currently selected.

#### 5.0.4 Navigation Policy (v0)

- Navigation driven by normal app interaction is not applicable in Editor View (clicks are consumed).
- Editor View clicks MUST NOT navigate.
- New-window behavior (`window.open`, target="_blank") MUST NOT spawn a new Electron window.
  - In Preview Mode (deferred), external links SHOULD open in the system default browser (host-owned policy).

#### 5.0.1 Discoverability Hint

When a preview session becomes ready, Skaffa displays a **non-intrusive discoverability hint** explaining the inspect controls:

- **Content:** "Click to inspect" and "Esc clears selection"
- **Display duration:** ~3-4 seconds with fade animation
- **Position:** Upper-left of Workbench UI, near preview controls
- **Ownership:** Hint is rendered by Skaffa UI (not injected into the guest app DOM)
- **Pointer events:** Never captures pointer events (user can click the canvas immediately)
- **Re-display:** Currently shows once per session; future versions may add manual re-show via help

**Rationale:** The hint ensures discoverability without polluting the guest app DOM or conflicting with app styling. By owning the hint in Skaffa's UI layer, we maintain architectural separation and prevent z-index conflicts, CSS specificity issues, or layout shifts in the user's app.

**v0 Note:** Since preview embedding in the Workbench is not yet implemented, the hint appears near the Preview Session List panel. When preview display integration is complete, the hint may be repositioned as an overlay on the preview area.

#### 5.0.2 Stopping/Exiting Preview Sessions

Preview sessions are stopped via **explicit UI controls**, not keyboard shortcuts:

- **Primary affordance:** Stop button in the Preview Session List panel (visible when session is in "ready" state)
- <kbd>Esc</kbd> MUST NOT stop/exit preview sessions (web apps commonly bind <kbd>Esc</kbd> to close modals, dialogs, etc.)

**Rationale:** Accidentally stopping a preview session during app interaction would be disruptive. An explicit click action provides clear intent and prevents accidental session termination.

### 5.1 Event Origin

- User clicks an instance in the embedded preview runtime.
- Runtime adapter resolves the clicked element to an `InstanceDescriptor`.
- Runtime adapter emits `runtime.selectionChanged { sessionId, selected }`.

### 5.2 Host Responsibilities

On selection:
- Main process records the current selection for that session.
- Main broadcasts selection to:
  - renderer UI (Inspector, Component Tree)
  - extension host (optional subscriptions)

The renderer MUST treat selection as **session-scoped**.

---

## 5.3 Active Route State (Optional, Router-Specific)

Some preview sessions will have a router integration (e.g. via a bundled “react-router” extension).

When available, Skaffa MAY consume a router-specific runtime stream describing the **active navigation state**, so the UI can highlight “what route is currently displaying” without guessing from `window.location` alone.

Recommended minimum signal:
- `sessionId`
- current `pathname`
- matched route ids (preferred) that join against `RouteId` in the Project Graph

This is intentionally separate from canonical route discovery:
- the canonical route list is derived statically from code and represented in the Project Graph
- the active route is derived from runtime state and may vary by environment/user/flags

---

## 6. Override Flow (Inspector Edit → Preview Update)

### 6.1 Authoritative Storage

For v0, Skaffa must have a single authoritative override store per workspace that can:
- apply a set/clear operation transactionally
- serialize (persist) and reload (see `docs/skaffa_override_model.md`)

### 6.2 Applying an Override

When the user edits a field in the Inspector:

1. Renderer submits a `set` operation to the host (via preload IPC).
2. Host updates the override store transactionally.
3. Host forwards the resulting `OverrideOp[]` to the runtime adapter for the active session.
4. Runtime adapter applies overrides and triggers re-render.
5. Renderer receives updated override state (to render “Overridden” UI affordances).

### 6.3 Reset/Clear

Reset is a `clear` operation:
- `clear` for a single prop path
- `clearInstance` for all overrides on an instance
- `clearAll` for the session target

---

## 7. Refresh / Reload / Reconnect

Reloads can occur due to:
- user navigation
- dev server HMR
- session restart

Required behavior:
- runtime adapter re-emits `runtime.ready` after reload
- host re-sends `host.init` with current overrides for that session target
- selection is cleared unless the runtime re-selects the same instance

---

## 8. Cross-Process Responsibilities (Summary)

### Renderer (Workbench UI)

- Presents session list, selection, Inspector
- Issues user-driven commands (start/stop session, set/clear overrides)
- Does not access Electron/Node directly

### Preload (Capability Gateway)

- Exposes typed APIs to the renderer (`window.skaffa.*`)
- Enforces that renderer effects are mediated through host

### MCP Clients (External AI Tools)

- Consume session/selection/graph/registry/overrides context via the MCP server.
- Never talk directly to preview runtime content or renderer internals.

### Main Process (Host)

- Owns session lifecycle + preview `WebContents`
- Owns the authoritative override store (or brokers access to it)
- Routes messages between renderer, extension host, and preview runtime

### Extension Host

- Runs modules (registries, adapters, graph producers)
- Produces project graph patches and consumes them for higher-level features
- Does not manipulate renderer state or preview DOM directly

### Preview Runtime + Runtime Adapter

- Renders the app/component
- Emits selection signals
- Applies non-destructive overrides

---

## 9. Non-Goals (v0)

- Remote preview execution
- Untrusted preview sandboxing UI
- Multi-session synchronization semantics beyond explicit user actions
