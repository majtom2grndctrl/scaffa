# Scaffa Preview Session Protocol (v0)

> **Status:** Draft / v0 shape  
> **Audience:** Scaffa core contributors, adapter authors, and extension authors  
> **Goal:** Precisely define preview session types, lifecycle, and the selection/override flows across main/renderer/preload/extension host/runtime adapter.

Related:
- [Architecture Plan](./index.md)
- [Scaffa Runtime Adapter Contract](./scaffa_runtime_adapter_contract.md)
- [Scaffa Override Model + Persistence](./scaffa_override_model.md)
- [IPC Boundaries + Key Sequence Diagrams](./scaffa_ipc_boundaries_and_sequences.md)
- [Scaffa MCP Server Contract](./scaffa_mcp_server_contract.md)

---

## 1. Definition

A **Preview Session** is a managed runtime that renders:

- the full app (`app` session)
- a harnessed component instance (`component` session)
- (future) a variant/snapshot context (`variant` session)

Sessions exist so Scaffa can:
- run multiple previews concurrently
- isolate state per preview
- route selection and overrides to the correct runtime

In v0, preview targets are treated as external runtimes (typically an HTTP server you start separately). Scaffa attaches to them via the session target.

---

## 2. Session Types (Canonical)

```ts
export type PreviewSessionType = "app" | "component" | "variant"; // "variant" is future

export type PreviewSessionId = string; // generated by Scaffa host

export type PreviewSessionTarget =
  | { type: "app"; url: string }
  | { type: "component"; componentTypeId: string; harnessUrl?: string }
  | { type: "variant"; variantId: string }; // future
```

Notes:
- For `app` sessions, `url` MUST be a full URL including protocol (e.g. `http://localhost:5173`).
- `component` sessions assume an adapter-provided harness that can render an isolated instance.
- `variant` sessions are reserved to preserve Iteration Deck compatibility (see `docs/scaffa_iteration_deck_integration.md`).

Examples:

```ts
// ✅ Correct
{ type: "app", url: "http://localhost:5173" }

// ❌ Wrong (missing protocol)
{ type: "app", url: "localhost:5173" }
```

---

## 3. Lifecycle and Ownership

### 3.1 Who Owns Sessions

- **Main process owns session lifetimes** and the underlying preview `WebContents` (BrowserView/WebView/BrowserWindow).
- **Renderer requests** session start/stop via preload APIs.
- **Extension host may request** sessions through the extension API (future), but never directly controls `WebContents`.

### 3.2 Session State Machine (v0)

```ts
export type PreviewSessionState =
  | "creating"
  | "loading"
  | "ready"
  | "reloading"
  | "stopped"
  | "disposed"
  | "error";
```

Required lifecycle events:
- `session.created`
- `session.ready` (runtime adapter handshake completed)
- `session.stopped` / `session.disposed`
- `session.error`

---

## 4. Handshake: Host ↔ Runtime Adapter

After the preview runtime loads, the **runtime adapter** must emit `runtime.ready` (see `docs/scaffa_runtime_adapter_contract.md`).

On `runtime.ready`, the host MUST:
- bind the runtime adapter to the session id
- send `host.init` with the session id + current override state for that session target

This guarantees:
- selection events can be attributed to a session
- overrides are re-applied after reload/navigation

---

## 5. Selection Flow (Pick-to-Select)

### 5.0 Interaction Model (v0): Interact vs Inspect

Scaffa must support two user intents against the same running app:

- **Interact** (default): clicks, links, keyboard shortcuts, and navigation behave like the app normally does.
- **Inspect** (gesture): the user intentionally "picks" an instance to drive Inspector editing.

#### 5.0.1 Inspect Gesture Contract

v0 input contract for inspect mode:
- Hold <kbd>Alt/Option</kbd> to highlight candidates under the cursor.
- <kbd>Alt/Option</kbd>+Click selects an instance and MUST prevent app interaction for that click.
- <kbd>Esc</kbd> clears selection when something is selected.

Recommended visual affordances:
- While holding <kbd>Alt/Option</kbd>, highlight the candidate instance under the cursor.
- After selection, show a persistent selection highlight so users can see what the Inspector is editing.

#### 5.0.2 Keyboard Shortcut Policy

Scaffa adopts a **minimal keyboard reservation policy** to avoid conflicting with web app shortcuts:

**Reserved by Scaffa (consumed, not passed through):**
- <kbd>Alt/Option</kbd> (modifier only) + hover/click for inspect gesture
- <kbd>Esc</kbd> when a component instance is selected (clears selection)

**Passed through to the app:**
- <kbd>Esc</kbd> when no selection exists (app receives the event)
- All other keyboard input (arrow keys, <kbd>Enter</kbd>, <kbd>Space</kbd>, letter keys, etc.)
- All keyboard shortcuts not explicitly listed as reserved above

**Rationale:** Web applications frequently bind keyboard shortcuts for navigation, modals, command palettes, and other features. Scaffa's preview experience prioritizes **interact by default**—users should be able to test and use the app normally without Scaffa intercepting their input.

**Future consideration:** If Scaffa adds a Play/Inspect mode toggle, the discoverability hint for that toggle should appear near the preview controls or in a non-intrusive overlay.

#### 5.0.3 Stopping/Exiting Preview Sessions

Preview sessions are stopped via **explicit UI controls**, not keyboard shortcuts:

- **Primary affordance:** Stop button in the Preview Session List panel (visible when session is in "ready" state)
- <kbd>Esc</kbd> MUST NOT stop/exit preview sessions (web apps commonly bind <kbd>Esc</kbd> to close modals, dialogs, etc.)

**Rationale:** Accidentally stopping a preview session during app interaction would be disruptive. An explicit click action provides clear intent and prevents accidental session termination.

### 5.1 Event Origin

- User performs an inspect gesture in the preview runtime (e.g. <kbd>Alt/Option</kbd>+Click).
- Runtime adapter resolves the clicked element to an `InstanceDescriptor`.
- Runtime adapter emits `runtime.selectionChanged { sessionId, selected }`.

### 5.2 Host Responsibilities

On selection:
- Main process records the current selection for that session.
- Main broadcasts selection to:
  - renderer UI (Inspector, Component Tree)
  - extension host (optional subscriptions)

The renderer MUST treat selection as **session-scoped**.

---

## 5.3 Active Route State (Optional, Router-Specific)

Some preview sessions will have a router integration (e.g. via a bundled “react-router” extension).

When available, Scaffa MAY consume a router-specific runtime stream describing the **active navigation state**, so the UI can highlight “what route is currently displaying” without guessing from `window.location` alone.

Recommended minimum signal:
- `sessionId`
- current `pathname`
- matched route ids (preferred) that join against `RouteId` in the Project Graph

This is intentionally separate from canonical route discovery:
- the canonical route list is derived statically from code and represented in the Project Graph
- the active route is derived from runtime state and may vary by environment/user/flags

---

## 6. Override Flow (Inspector Edit → Preview Update)

### 6.1 Authoritative Storage

For v0, Scaffa must have a single authoritative override store per workspace that can:
- apply a set/clear operation transactionally
- serialize (persist) and reload (see `docs/scaffa_override_model.md`)

### 6.2 Applying an Override

When the user edits a field in the Inspector:

1. Renderer submits a `set` operation to the host (via preload IPC).
2. Host updates the override store transactionally.
3. Host forwards the resulting `OverrideOp[]` to the runtime adapter for the active session.
4. Runtime adapter applies overrides and triggers re-render.
5. Renderer receives updated override state (to render “Overridden” UI affordances).

### 6.3 Reset/Clear

Reset is a `clear` operation:
- `clear` for a single prop path
- `clearInstance` for all overrides on an instance
- `clearAll` for the session target

---

## 7. Refresh / Reload / Reconnect

Reloads can occur due to:
- user navigation
- dev server HMR
- session restart

Required behavior:
- runtime adapter re-emits `runtime.ready` after reload
- host re-sends `host.init` with current overrides for that session target
- selection is cleared unless the runtime re-selects the same instance

---

## 8. Cross-Process Responsibilities (Summary)

### Renderer (Workbench UI)

- Presents session list, selection, Inspector
- Issues user-driven commands (start/stop session, set/clear overrides)
- Does not access Electron/Node directly

### Preload (Capability Gateway)

- Exposes typed APIs to the renderer (`window.scaffa.*`)
- Enforces that renderer effects are mediated through host

### MCP Clients (External AI Tools)

- Consume session/selection/graph/registry/overrides context via the MCP server.
- Never talk directly to preview runtime content or renderer internals.

### Main Process (Host)

- Owns session lifecycle + preview `WebContents`
- Owns the authoritative override store (or brokers access to it)
- Routes messages between renderer, extension host, and preview runtime

### Extension Host

- Runs modules (registries, adapters, graph producers)
- Produces project graph patches and consumes them for higher-level features
- Does not manipulate renderer state or preview DOM directly

### Preview Runtime + Runtime Adapter

- Renders the app/component
- Emits selection signals
- Applies non-destructive overrides

---

## 9. Non-Goals (v0)

- Remote preview execution
- Untrusted preview sandboxing UI
- Multi-session synchronization semantics beyond explicit user actions
