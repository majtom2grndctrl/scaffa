# Scaffa Preview Session Protocol (v0)

> **Status:** Draft / v0 shape  
> **Audience:** Scaffa core contributors, adapter authors, and extension authors  
> **Goal:** Precisely define preview session types, lifecycle, and the selection/override flows across main/renderer/preload/extension host/runtime adapter.

## Agent TL;DR

- Load when: touching **preview session lifecycle**, **selection routing**, or **override routing** across processes.
- Primary artifacts: `PreviewSessionTarget`, `PreviewSessionId`, session lifecycle events, and “which process owns what”.
- Don’t load when: you only need override data shape (`docs/scaffa_override_model.md`) or adapter internals (`docs/scaffa_runtime_adapter_contract.md`).
- Also load: `docs/scaffa_ipc_boundaries_and_sequences.md` for concrete sequence diagrams.

Related:
- [Architecture Plan](./index.md)
- [Scaffa Runtime Adapter Contract](./scaffa_runtime_adapter_contract.md)
- [Scaffa Override Model + Persistence](./scaffa_override_model.md)
- [IPC Boundaries + Key Sequence Diagrams](./scaffa_ipc_boundaries_and_sequences.md)
- [Scaffa MCP Server Contract](./scaffa_mcp_server_contract.md)

---

## 1. Definition

A **Preview Session** is a managed runtime that renders:

- the full app (`app` session)
- a harnessed component instance (`component` session)
- (future) a variant/snapshot context (`variant` session)

Sessions exist so Scaffa can:
- run multiple previews concurrently
- isolate state per preview
- route selection and overrides to the correct runtime

In v0, preview targets are treated as external runtimes (typically an HTTP server you start separately). Scaffa attaches to them via the session target.

### 1.1 Editor View (v0) and Preview Mode (Deferred)

In v0, Scaffa focuses on **Editor View**:

- **Editor View**: embedded in the center Workbench workspace. Clicks are consumed for **selection + inspection** (click-to-select by default).

**Preview Mode** (a separate interact-by-default session) is deferred until after v0 “save to disk” workflows are established.

---

## 2. Session Types (Canonical)

```ts
export type PreviewSessionType = "app" | "component" | "variant"; // "variant" is future

export type PreviewSessionId = string; // generated by Scaffa host

export type PreviewSessionTarget =
  | { type: "app"; url: string }
  | { type: "component"; componentTypeId: string; harnessUrl?: string }
  | { type: "variant"; variantId: string }; // future
```

Notes:
- For `app` sessions, `url` MUST be a full URL including protocol (e.g. `http://localhost:5173`).
- `component` sessions assume an adapter-provided harness that can render an isolated instance.
- `variant` sessions are reserved to preserve Iteration Deck compatibility (see `docs/scaffa_iteration_deck_integration.md`).

Examples:

```ts
// ✅ Correct
{ type: "app", url: "http://localhost:5173" }

// ❌ Wrong (missing protocol)
{ type: "app", url: "localhost:5173" }
```

---

## 3. Lifecycle and Ownership

### 3.1 Who Owns Sessions

- **Main process owns session lifetimes** and the underlying preview `WebContents` (BrowserView/WebView/BrowserWindow).
- **Renderer requests** session start/stop via preload APIs.
- **Extension host may request** sessions through the extension API (future), but never directly controls `WebContents`.

### 3.2 Session State Machine (v0)

```ts
export type PreviewSessionState =
  | "creating"
  | "loading"
  | "ready"
  | "reloading"
  | "stopped"
  | "disposed"
  | "error";
```

Required lifecycle events:
- `session.created`
- `session.ready` (runtime adapter handshake completed)
- `session.stopped` / `session.disposed`
- `session.error`

---

## 4. Handshake: Host ↔ Runtime Adapter

After the preview runtime loads, the **runtime adapter** must emit `runtime.ready` (see `docs/scaffa_runtime_adapter_contract.md`).

On `runtime.ready`, the host MUST:
- bind the runtime adapter to the session id
- send `host.init` with the session id + current override state for that session target

This guarantees:
- selection events can be attributed to a session
- overrides are re-applied after reload/navigation

---

## 5. Selection Flow (Pick-to-Select)

### 5.0 Interaction Model (v0): Editor View Click-to-Select

In v0, the embedded runtime is an editor canvas:

- Any click selects the nearest resolvable instance.
- Clicks MUST NOT trigger app interaction (no navigation, no button handlers) in the editor session.
- <kbd>Esc</kbd> clears selection when something is selected.

Recommended affordances:
- Persistent selection highlight for the selected instance.
- Optional hover highlight for candidates under the cursor.

#### 5.0.1 Discoverability Hint

When a preview session becomes ready, Scaffa displays a **non-intrusive discoverability hint** explaining the inspect controls:

- **Content:** "Click to inspect" and "Esc clears selection"
- **Display duration:** ~3-4 seconds with fade animation
- **Position:** Upper-left of Workbench UI, near preview controls
- **Ownership:** Hint is rendered by Scaffa UI (not injected into the guest app DOM)
- **Pointer events:** Never captures pointer events (user can click the canvas immediately)
- **Re-display:** Currently shows once per session; future versions may add manual re-show via help

**Rationale:** The hint ensures discoverability without polluting the guest app DOM or conflicting with app styling. By owning the hint in Scaffa's UI layer, we maintain architectural separation and prevent z-index conflicts, CSS specificity issues, or layout shifts in the user's app.

**v0 Note:** Since preview embedding in the Workbench is not yet implemented, the hint appears near the Preview Session List panel. When preview display integration is complete, the hint may be repositioned as an overlay on the preview area.

#### 5.0.2 Stopping/Exiting Preview Sessions

Preview sessions are stopped via **explicit UI controls**, not keyboard shortcuts:

- **Primary affordance:** Stop button in the Preview Session List panel (visible when session is in "ready" state)
- <kbd>Esc</kbd> MUST NOT stop/exit preview sessions (web apps commonly bind <kbd>Esc</kbd> to close modals, dialogs, etc.)

**Rationale:** Accidentally stopping a preview session during app interaction would be disruptive. An explicit click action provides clear intent and prevents accidental session termination.

### 5.1 Event Origin

- User clicks an instance in the embedded preview runtime.
- Runtime adapter resolves the clicked element to an `InstanceDescriptor`.
- Runtime adapter emits `runtime.selectionChanged { sessionId, selected }`.

### 5.2 Host Responsibilities

On selection:
- Main process records the current selection for that session.
- Main broadcasts selection to:
  - renderer UI (Inspector, Component Tree)
  - extension host (optional subscriptions)

The renderer MUST treat selection as **session-scoped**.

---

## 5.3 Active Route State (Optional, Router-Specific)

Some preview sessions will have a router integration (e.g. via a bundled “react-router” extension).

When available, Scaffa MAY consume a router-specific runtime stream describing the **active navigation state**, so the UI can highlight “what route is currently displaying” without guessing from `window.location` alone.

Recommended minimum signal:
- `sessionId`
- current `pathname`
- matched route ids (preferred) that join against `RouteId` in the Project Graph

This is intentionally separate from canonical route discovery:
- the canonical route list is derived statically from code and represented in the Project Graph
- the active route is derived from runtime state and may vary by environment/user/flags

---

## 6. Override Flow (Inspector Edit → Preview Update)

### 6.1 Authoritative Storage

For v0, Scaffa must have a single authoritative override store per workspace that can:
- apply a set/clear operation transactionally
- serialize (persist) and reload (see `docs/scaffa_override_model.md`)

### 6.2 Applying an Override

When the user edits a field in the Inspector:

1. Renderer submits a `set` operation to the host (via preload IPC).
2. Host updates the override store transactionally.
3. Host forwards the resulting `OverrideOp[]` to the runtime adapter for the active session.
4. Runtime adapter applies overrides and triggers re-render.
5. Renderer receives updated override state (to render “Overridden” UI affordances).

### 6.3 Reset/Clear

Reset is a `clear` operation:
- `clear` for a single prop path
- `clearInstance` for all overrides on an instance
- `clearAll` for the session target

---

## 7. Refresh / Reload / Reconnect

Reloads can occur due to:
- user navigation
- dev server HMR
- session restart

Required behavior:
- runtime adapter re-emits `runtime.ready` after reload
- host re-sends `host.init` with current overrides for that session target
- selection is cleared unless the runtime re-selects the same instance

---

## 8. Cross-Process Responsibilities (Summary)

### Renderer (Workbench UI)

- Presents session list, selection, Inspector
- Issues user-driven commands (start/stop session, set/clear overrides)
- Does not access Electron/Node directly

### Preload (Capability Gateway)

- Exposes typed APIs to the renderer (`window.scaffa.*`)
- Enforces that renderer effects are mediated through host

### MCP Clients (External AI Tools)

- Consume session/selection/graph/registry/overrides context via the MCP server.
- Never talk directly to preview runtime content or renderer internals.

### Main Process (Host)

- Owns session lifecycle + preview `WebContents`
- Owns the authoritative override store (or brokers access to it)
- Routes messages between renderer, extension host, and preview runtime

### Extension Host

- Runs modules (registries, adapters, graph producers)
- Produces project graph patches and consumes them for higher-level features
- Does not manipulate renderer state or preview DOM directly

### Preview Runtime + Runtime Adapter

- Renders the app/component
- Emits selection signals
- Applies non-destructive overrides

---

## 9. Non-Goals (v0)

- Remote preview execution
- Untrusted preview sandboxing UI
- Multi-session synchronization semantics beyond explicit user actions
