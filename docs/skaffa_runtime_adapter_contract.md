# Scaffa Runtime Adapter Contract (v0)

> **Status:** Draft / v0 shape  
> **Audience:** Framework adapter authors (first‑party and internal)  
> **Goal:** Define the framework‑agnostic contract for runtime instance identity, selection, and applying non‑destructive prop overrides inside preview runtimes.

## Agent TL;DR

- Load when: implementing or modifying a **framework runtime adapter** (click-to-select, instance identity, apply/clear overrides).
- Key invariants: `componentTypeId` is the **join key** across registry/graph/runtime/overrides; v0 selection is click-to-select in Editor View (Preview Mode is deferred).
- Primary concerns: instance identity, selection events, override application, lifecycle hooks.
- Also load: `docs/scaffa_runtime_adapter_integration_guide.md`, `docs/scaffa_preview_session_protocol.md`, `docs/scaffa_override_model.md`.

Related:
- [Architecture Plan](./index.md)
- [Scaffa Runtime Adapter Integration Guide](./scaffa_runtime_adapter_integration_guide.md)
- [Scaffa Preview Session Protocol](./scaffa_preview_session_protocol.md)
- [Scaffa Override Model + Persistence](./scaffa_override_model.md)
- [Scaffa Project Graph Schema + Patch Protocol](./scaffa_project_graph_schema.md)

---

## 1. What a “Runtime Adapter” Is

A **Runtime Adapter** is the framework-specific code that runs *inside the preview runtime* (the app preview or component preview) to provide Scaffa with:

- **Instance identity** (what component instance is this?)
- **Click-to-select** (what instance did the user click?)
- **Override application** (apply / clear prop overrides without rewriting code)
- **Lifecycle hooks** (connect, disconnect, reload)

This is distinct from:
- **Component registries:** type-level metadata for the Inspector (what props are editable, which controls, etc.)
- **Project graph producers:** workspace analysis that populates routes/types/relationships and emits graph patches
- **Extension host code:** runs in a separate process and never directly mutates the renderer or preview DOM

Production expectation:
- Projects SHOULD be able to build and run in production without Scaffa installed or enabled.
- Runtime adapter integration is intended to be dev-only (or Scaffa-only) instrumentation of the preview runtime.
- Recommended v0 integration path is the Harness Model (managed launcher + virtual harness entry), so projects do not need Scaffa editor/runtime adapter imports in production code.

---

## 2. Required Responsibilities (v0)

### 2.1 Instance Identity

The adapter MUST be able to produce an `InstanceDescriptor` for a selected UI element:

- `componentTypeId` is **stable** (matches registry + graph type IDs; it is the join key across boundaries)
- `instanceId` is stable for at least the lifetime of a preview session
- optional `source` is provided when available (file/line/column)

The adapter SHOULD provide an `instanceLocator` stable across reloads when feasible.

### 2.2 Selection Signaling

The adapter MUST emit selection events when the user clicks/taps in the preview:

- selection carries `sessionId` + `InstanceDescriptor`
- selection must feel immediate; throttle only if necessary
- adapter must follow Scaffa’s interaction policy for the session (Editor View vs Preview Mode)

v0 standard:
- Default to **click-to-select** in the Editor View canvas.
- Consume clicks so app navigation/handlers do not fire in the editor session.

Deferred (post-v0):
- Preview Mode as a separate interact-by-default session.
- In Preview Mode, selection should be gated behind an explicit inspect gesture (e.g. <kbd>Alt/Option</kbd>+Click).

### 2.3 Override Application

The adapter MUST support applying and clearing overrides:

- set/update an override for `instanceId + propPath`
- clear an override for `instanceId + propPath`
- clear all overrides for an instance
- clear all overrides for a session (used for “Reset Session”)

Overrides MUST be applied **non-destructively** (no rewriting source files).

### 2.4 Lifecycle / Teardown

The adapter MUST:

- emit a “ready/handshake” signal once installed
- tolerate reloads/navigation (re-handshake on re-initialization)
- clean up listeners on teardown (hot reload, session stop)

---

## 3. Canonical Data Shapes

These are the minimal cross-boundary shapes used by runtime adapters, preview sessions, overrides, and the Inspector.

```ts
export type AdapterId = string; // e.g. "react", "nextjs-react", "remix-react"

export type PreviewSessionId = string; // opaque, generated by Scaffa host

// Stable across the workspace. Must match component registry keys.
export type ComponentTypeId = string; // e.g. "ui.button"

// Stable for the lifetime of a preview session. Prefer stable across reload when feasible.
export type InstanceId = string; // e.g. "inst_01H..."

// Address into props for overrides. Use JSON Pointer (RFC 6901) to avoid dot-path ambiguity.
export type PropPath = string; // e.g. "/variant", "/style/color", "/items/0/label"

export type SourceRef = {
  filePath: string;
  line: number; // 1-based
  column?: number; // 1-based
};

export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | { [key: string]: JsonValue };

export type InstanceDescriptor = {
  sessionId: PreviewSessionId;
  instanceId: InstanceId;
  componentTypeId: ComponentTypeId;

  // Human-facing hints (optional)
  displayName?: string; // e.g. "Button"
  keyHint?: string; // e.g. React key or stable hint, if available
  source?: SourceRef;

  /**
   * Optional JSON-only props snapshot for Inspector display.
   * If provided, it MUST be JSON-serializable.
   */
  props?: { [key: string]: JsonValue };

  // Optional: helps persist overrides across reloads when InstanceId cannot be stable.
  // (v0 can ship without this, but it preserves Iteration Deck compatibility.)
  instanceLocator?: JsonValue;
};
```

---

## 4. Runtime ↔ Host Protocol (Minimal)

Runtime adapters communicate with Scaffa via a message transport owned by the **Preview Session** (see `docs/scaffa_preview_session_protocol.md`). The contract below describes minimum intent; the exact transport may be `postMessage`, `MessagePort`, or an Electron bridge owned by the session.

### 4.1 Runtime → Host Events

```ts
export type RuntimeEvent =
  | {
      type: "runtime.ready";
      adapterId: AdapterId;
      adapterVersion: string;
      capabilities: {
        selection: true;
        overrides: true;
      };
    }
  | {
      type: "runtime.selectionChanged";
      sessionId: PreviewSessionId;
      selected: InstanceDescriptor | null;
      causedBy: "click" | "programmatic";
    };
```

### 4.2 Host → Runtime Commands

```ts
export type HostCommand =
  | {
      type: "host.init";
      sessionId: PreviewSessionId;
      initialOverrides: OverrideOp[];
    }
  | {
      type: "host.applyOverrides";
      sessionId: PreviewSessionId;
      ops: OverrideOp[];
    };
```

With:

```ts
export type OverrideOp =
  | { op: "set"; instanceId: InstanceId; path: PropPath; value: JsonValue }
  | { op: "clear"; instanceId: InstanceId; path: PropPath }
  | { op: "clearInstance"; instanceId: InstanceId }
  | { op: "clearAll" };
```

---

## 5. Boundary Clarifications

### 5.1 Runtime Adapter vs Component Registry

- Registry answers: “What does `ui.button` expose to the Inspector?” (type-level)
- Runtime adapter answers: “Which instance is this click?” and “How do I apply `/variant='primary'` to that instance?” (instance-level)

Registry data MUST NOT be required to *interpret* selection. Selection is derived from runtime identity.

v0 policy note (Harness Model): a launcher/adapter may choose to only instrument registry-listed component types. In that case, clicks that do not resolve to an instrumented instance will produce `selected: null` (or the nearest instrumented ancestor, if supported).

### 5.2 Runtime Adapter vs Extension Host

- Extension host can **author** adapters and ship adapter bundles, but it does not run inside the preview DOM.
- Runtime adapter emits selection + accepts overrides; it does not analyze the filesystem or own project graph state.

### 5.3 Runtime Adapter vs Project Graph Producer

- Graph producers build/update the canonical graph and emit patches.
- Runtime adapters may emit *instance identity events* that producers translate into session-scoped instance nodes (optional in v0).

---

## 6. React-First Example (Illustrative, Not the Contract)

A React adapter can implement this contract by combining:

1. **Instance identity**  
   - Assign a stable `instanceId` during render using a small wrapper component (e.g. `ScaffaInstanceBoundary`) or React instrumentation.
   - Optionally annotate a DOM node with `data-scaffa-instance-id` for hit-testing selection.

2. **Click-to-select**  
   - Capture pointer events at the document root.
   - Walk up the DOM to find the nearest `data-scaffa-instance-id`.
   - Emit `runtime.selectionChanged` with `{ sessionId, instanceId, componentTypeId }`.
   - Prevent default for editor clicks (so app interaction remains suppressed in Editor View).

3. **Applying overrides**  
   - Maintain an override map keyed by `instanceId`.
   - Provide overrides via React context that components (or a boundary wrapper) consult to replace incoming props.
   - Apply `OverrideOp[]` by updating the map and triggering a re-render.

The important part is that the contract remains framework-agnostic: React is one implementation of the runtime-side responsibilities.

---

## 7. Known Limitations (Visual Highlights)

### 7.1 Editor View Highlighting

The v0 runtime adapter uses CSS `outline` and `box-shadow` to visually indicate:
- **Hover candidate** (optional): 2px dashed outline
- **Selected instance**: 3px solid outline

**Accessibility features:**
- Multiple non-color cues: outline style (dashed vs solid) and width (2px vs 3px)
- High-contrast colors (fuchsia for hover, cyan for selection)
- Box-shadow provides visibility on both light and dark backgrounds
- Uses `outline` (not `border`) to avoid layout shifts

### 7.2 Limitations

**Portal and iframe boundaries:**
- Highlights only work within the same document context
- React Portals to other DOM nodes: ✅ works (same document)
- iframes with different origins: ❌ cannot highlight (cross-origin restriction)
- iframes with same origin: ⚠️ requires adapter initialization in iframe context

**Shadow DOM:**
- Closed shadow roots: ❌ cannot highlight (encapsulation boundary)
- Open shadow roots: ⚠️ may work if adapter traverses shadow DOM boundaries

**CSS stacking and visibility:**
- Elements with `z-index` conflicts may overlap highlights
- Elements with `overflow: hidden` on ancestors may clip outline/shadow
- `position: fixed` or `sticky` elements may cause highlight positioning issues

**Performance:**
- Highlights use CSS animations and box-shadow filters
- On low-end devices, large numbers of highlighted elements may cause jank
- Recommendation: highlight one candidate + one selected instance only

### 7.3 Future Improvements

Potential enhancements beyond v0:
- Scaffa-owned overlay layer (eliminates most CSS conflicts)
- Canvas-based highlights (avoids stacking context issues)
- Cross-iframe coordination (requires postMessage protocol)
- Customizable highlight colors for accessibility preferences

---

## 8. Non-Goals (v0)

- Full runtime component tree introspection
- Editing component type definitions in code
- Arbitrary DOM mutation from Scaffa
- Untrusted sandboxing/permissions (trusted runtime for v0)
